# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DownloadSentinel
                                 A QGIS plugin
 This plugin allows users to be able to download Sentinel 2 images.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-06-05
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Murat Çalışkan
        email                : caliskan.murat.20@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QDate
from qgis.PyQt.QtGui import QIcon, QPixmap
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox, QLineEdit

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .sentinel_downloader_dialog import DownloadSentinelDialog

from .DrawRect import RectangleMapTool

from qgis.core import QgsVectorLayer, QgsProject

from osgeo import osr, ogr, gdal
from datetime import datetime, timedelta
import requests, time, os, pyproj, zipfile
from glob import glob
import numpy as np
from shapely.geometry import shape
from shapely.ops import transform
import pandas as pd
from collections import defaultdict


class DownloadSentinel:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = QgsProject.instance()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'DownloadSentinel_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sentinel 2 Image Downloader')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('DownloadSentinel', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/sentinel_downloader/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Sentinel 2 Image Downloader'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Sentinel 2 Image Downloader'),
                action)
            self.iface.removeToolBarIcon(action)
    
    def selectInputFile(self):
        self.dlg.le_inputfile.setText("")
        filePath, _filter = QFileDialog.getOpenFileName(self.dlg, "Select footprint File","", 'GPKG(*.gpkg *.GPKG)')
        self.dlg.le_inputfile.setText(filePath)

    def selectOutputFolder(self):
        sender = self.dlg.sender()
        object_name = sender.objectName()
        
        if object_name == "btn_browse":        
            self.dlg.le_outputFolder.setText("")
            output_dir = QFileDialog.getExistingDirectory(None, 'Open working directory', "", QFileDialog.ShowDirsOnly)
            self.dlg.le_outputFolder.setText(output_dir)
        
        elif object_name == "btn_browse_2":        
            self.dlg.le_outputFolder_2.setText("")
            output_dir = QFileDialog.getExistingDirectory(None, 'Open working directory', "", QFileDialog.ShowDirsOnly)
            self.dlg.le_outputFolder_2.setText(output_dir)
        
    def getTransformedGeometry(self, geom_wkt, srs_wkt):
        geom = ogr.CreateGeometryFromWkt(geom_wkt)
        
        sr_1 = osr.SpatialReference()
        sr_1.ImportFromWkt(srs_wkt)
        
        sr_2 = osr.SpatialReference()
        sr_2.ImportFromEPSG(4326)
                
        if not sr_1.IsSame(sr_2):
            sr_2.SetAxisMappingStrategy(osr.OAMS_TRADITIONAL_GIS_ORDER)
            coord_trans = osr.CoordinateTransformation(sr_1, sr_2)
            geom.Transform(coord_trans)
        
        return geom
    
    def getTransformedGeometry2(self, geom_wkt, srs_wkt):
        geom = ogr.CreateGeometryFromWkt(geom_wkt)
        
        sr_2 = osr.SpatialReference()
        sr_2.ImportFromWkt(srs_wkt)
        
        sr_1 = osr.SpatialReference()
        sr_1.ImportFromEPSG(4326)
                
        if not sr_1.IsSame(sr_2):
            sr_1.SetAxisMappingStrategy(osr.OAMS_TRADITIONAL_GIS_ORDER)
            coord_trans = osr.CoordinateTransformation(sr_1, sr_2)
            geom.Transform(coord_trans)
        
        return geom.GetEnvelope()
        
    def createGPKG(self, products_all, outfile, driver_name = "GPKG"):
        driver = ogr.GetDriverByName(driver_name)
        ds = driver.CreateDataSource(outfile)
        srs = osr.SpatialReference()
        srs.ImportFromEPSG(4326)
        
        layer = ds.CreateLayer("footprints", srs, ogr.wkbPolygon)
        
        for c, d in products_all.dtypes.items():
            if c == "wkt":
                continue
            if d.name == "object":
                t = ogr.OFTString
            elif "date" in d.name:
                t = ogr.OFTDateTime
            elif "int" in d.name:
                t = ogr.OFTInteger64
            elif "float" in d.name:
                t = ogr.OFTReal
            
            
            layer.CreateField(ogr.FieldDefn(c, t))
       
        
        defn = layer.GetLayerDefn()
        
        for e, (_,row) in enumerate(products_all.iterrows()):
            feat = ogr.Feature(defn)
            
            feat.SetField('id', e)
            
            for k,v in row.items():
                if k == "wkt":
                    feat.SetGeometry(ogr.CreateGeometryFromWkt(v))
                else:
                    try:
                        if "date" in k:
                            feat.SetField(k, str(v))
                        else:
                            feat.SetField(k, v)
                    except:
                        print(k,v)
        
            layer.CreateFeature(feat)
        
        ds.FlushCache()
        ds = layer = defn = feat = None
    
    def getCanvasExtent(self):        
        canvas = QgsProject.instance()
        srs_wkt = canvas.crs().toWkt()
        ext = self.iface.mapCanvas().extent()
        
        geom = self.getTransformedGeometry(ext.asWktPolygon(), srs_wkt)        
        minx, maxx, miny, maxy = geom.GetEnvelope()
            
        self.dlg.sb_extent_minx.setValue(minx)
        self.dlg.sb_extent_miny.setValue(miny)
        self.dlg.sb_extent_maxx.setValue(maxx)
        self.dlg.sb_extent_maxy.setValue(maxy)
     
    def getLayerExtent(self):
        layerName = self.dlg.cb_layers.currentText()
        layer = QgsProject.instance().mapLayersByName(layerName)[0]
        srs_wkt = layer.crs().toWkt()        
        ext = layer.extent()
        
        geom = self.getTransformedGeometry(ext.asWktPolygon(), srs_wkt)        
        minx, maxx, miny, maxy = geom.GetEnvelope()
                    
        self.dlg.sb_extent_minx.setValue(minx)
        self.dlg.sb_extent_miny.setValue(miny)
        self.dlg.sb_extent_maxx.setValue(maxx)
        self.dlg.sb_extent_maxy.setValue(maxy)
    
    def getDrawnCoor(self, canvas):
        self.dlg.showMinimized()
        self.rect = RectangleMapTool(canvas, self.dlg)
        canvas.setMapTool(self.rect)
    
    def fillCombo(self):
        val_min = self.dlg.cb_minzoom.currentText()
        val_max = self.dlg.cb_maxzoom.currentText()
        
        if int(val_min) > int(val_max):
            self.dlg.lbl_checkzoom.setStyleSheet("color:red;")
            self.dlg.lbl_checkzoom.setText("Invalid zoom levels!")
            self.dlg.btn_execute.setEnabled(False)
        else:
            self.dlg.lbl_checkzoom.setText("")
            self.dlg.btn_execute.setEnabled(True)
            
    def outFolderCheck(self):
        sender = self.dlg.sender()
        object_name = sender.objectName()
        
        if object_name == "le_outputFolder":
            folder_path = self.dlg.le_outputFolder.text()
            
            if os.path.isdir(folder_path):
                self.folderCheck = True
                self.dlg.lbl_message_3.setText("")
            else:
                self.folderCheck = False
                self.dlg.lbl_message_3.setText('<html><head/><body><p><span style=" color:#ff0000;"> Invalid folder path! </span></p></body></html>')
            
            self.dlg.btn_execute.setEnabled(all((self.dateCheck, self.extentCheck, self.folderCheck)))
            
        elif object_name == "le_outputFolder_2":
            folder_path = self.dlg.le_outputFolder_2.text()
            
            if os.path.isdir(folder_path):
                self.folderCheck2 = True
                self.dlg.lbl_message_4.setText("")
            else:
                self.folderCheck2 = False
                self.dlg.lbl_message_4.setText('<html><head/><body><p><span style=" color:#ff0000;"> Invalid folder path! </span></p></body></html>')
            
            self.dlg.btn_execute_2.setEnabled(all((self.fileCheck2, self.folderCheck2, self.loginCheck2)))
        
    def inputFileCheck(self):
        file_path = self.dlg.le_inputfile.text()        
        res = ogr.Open(file_path)
        
        if res:
            self.fileCheck2 = True
            self.dlg.lbl_message_5.setText("")
        else:
            self.fileCheck2 = False
            self.dlg.lbl_message_5.setText('<html><head/><body><p><span style=" color:#ff0000;"> Invalid file path! </span></p></body></html>')
        
        self.dlg.btn_execute_2.setEnabled(all((self.fileCheck2, self.folderCheck2, self.loginCheck2)))
    
    def showPassword(self, *arg, **kwargs):
        self.dlg.lbl_img.setPixmap(self.pixmap_hide)
        self.dlg.le_password.setEchoMode(QLineEdit.Normal)
    
    def hidePassword(self, *arg, **kwargs):
        self.dlg.lbl_img.setPixmap(self.pixmap_show)   
        self.dlg.le_password.setEchoMode(QLineEdit.Password)     
    
    def checkExtractOptions(self):
        sender = self.dlg.sender()
        oname = sender.objectName()
        
        if oname == "cb_extract_files":
            if sender.isChecked():
                self.dlg.cb_delete_zip_file.setEnabled(True)
                self.dlg.cb_ndvi.setEnabled(True)
                self.dlg.cb_ndwi.setEnabled(True)
                self.dlg.cb_clip.setEnabled(True)
                self.dlg.cb_merge.setEnabled(True)
            else:
                self.dlg.cb_delete_zip_file.setEnabled(False)
                self.dlg.cb_ndvi.setEnabled(False)
                self.dlg.cb_ndwi.setEnabled(False)
                self.dlg.cb_clip.setEnabled(False)
                self.dlg.cb_merge.setEnabled(False)
                
                self.dlg.cb_delete_zip_file.setChecked(False)
                self.dlg.cb_ndvi.setChecked(False)
                self.dlg.cb_ndwi.setChecked(False)
                self.dlg.cb_clip.setChecked(False)
                self.dlg.cb_merge.setChecked(False)
        
        elif oname == "cb_ql":
            if not sender.isChecked():
                self.dlg.cb_extract_files.setEnabled(True)
            else:
                self.dlg.cb_extract_files.setEnabled(False)
                self.dlg.cb_delete_zip_file.setEnabled(False)
                self.dlg.cb_ndvi.setEnabled(False)
                self.dlg.cb_ndwi.setEnabled(False)
                self.dlg.cb_clip.setEnabled(False)
                self.dlg.cb_merge.setEnabled(False)
                
                self.dlg.cb_extract_files.setChecked(False)
                self.dlg.cb_delete_zip_file.setChecked(False)
                self.dlg.cb_ndvi.setChecked(False)
                self.dlg.cb_ndwi.setChecked(False)
                self.dlg.cb_clip.setChecked(False)
                self.dlg.cb_merge.setChecked(False)
            
            
    def checkExtent(self):
        minx = float(self.dlg.sb_extent_minx.value())
        maxx = float(self.dlg.sb_extent_maxx.value())
        miny = float(self.dlg.sb_extent_miny.value())
        maxy = float(self.dlg.sb_extent_maxy.value())  
        
        controls = [maxx > minx,
                    maxy > miny]
        
        if all(controls):
            self.extentCheck = True
            self.dlg.lbl_message_2.setText("")
        else:
            self.extentCheck = False
            self.dlg.lbl_message_2.setText('<html><head/><body><p><span style=" color:#ff0000;"> Invalid extent value! </span></p></body></html>')
        
        
        self.dlg.btn_execute.setEnabled(all((self.dateCheck, self.extentCheck, self.folderCheck)))
    
    def checkDates(self):
        enabled = []
        if self.dlg.dt_endDate.dateTime().toPyDateTime() < self.dlg.dt_startDate.dateTime().toPyDateTime():
            enabled.append(False)
            message = '<html><head/><body><p><span style=" color:#ff0000;"> Invalid Start or End date! </span></p></body></html>'
        else:
            enabled.append(True)
            message = ""
            
        if self.dlg.dt_startDate.dateTime().toPyDateTime() > datetime.now():
            enabled.append(False)
            message = '<html><head/><body><p><span style=" color:#ff0000;"> Invalid Start date! </span></p></body></html>'
        else:
            enabled.append(True)
            
        if all(enabled):
            self.dateCheck = True
        else:
            self.dateCheck = False
            
        self.dlg.btn_execute.setEnabled(all((self.dateCheck, self.extentCheck, self.folderCheck)))
        self.dlg.lbl_message.setText(message)
                
    
    def createLog(self, message, end=False, clear=False):
        txt = f"-- {str(datetime.now())}\n{message}\n------------------------------------------------------------------"
        # txt = (txt + "\n\n------------------------------------------------------------------\n\n") if end else txt
        
        if clear:
            self.dlg.pe_log.clear() 
            
        self.dlg.pe_log.appendPlainText(txt + "\n")
        self.dlg.processEvents()       
    
    def array2raster(self, out_raster_path, geotransform, srs_wkt, band_infos, dtype):
        cols = band_infos[0][0].shape[1]
        rows = band_infos[0][0].shape[0]
    
        driver = gdal.GetDriverByName('GTiff')
        outRaster = driver.Create(out_raster_path, cols, rows, len(band_infos), dtype, options=['COMPRESS=DEFLATE'])
        outRaster.SetGeoTransform(geotransform)
        outRaster.SetProjection(srs_wkt)
        
        for e, (array, nodataval) in enumerate(band_infos, 1):
            outband = outRaster.GetRasterBand(e)
            outband.WriteArray(array)
            outband.SetNoDataValue(nodataval)
            outband.FlushCache()
        
        outRaster.FlushCache()
        
        del outRaster, outband
    
    def checkCredentials(self):
        self.username = self.dlg.le_username.text()
        self.password = self.dlg.le_password.text()
        
        data = {
            "client_id": "cdse-public",
            "username": self.username,
            "password": self.password,
            "grant_type": "password",
            }
        try:
            r = requests.post("https://identity.dataspace.copernicus.eu/auth/realms/CDSE/protocol/openid-connect/token",
            data=data,
            )
            
            if r.status_code == 200:
                self.bear = r.json()["access_token"]
                self.dlg.lbl_message_6.setText('<html><head/><body><p><span style=" color:#05eb14;"> Login successful! </span></p></body></html>')
                self.loginCheck2 = True
            else:
                message = f"ERROR!!!\nStatus Code : {r.status_code}\n{r.text}"
                self.createLog(message, end=False, clear=False)
        
        except Exception as e:
            message = r.status_code, f"ERROR: {str(e)}"
            self.createLog(message, end=False, clear=False)
        
        self.dlg.btn_execute_2.setEnabled(all((self.fileCheck2, self.folderCheck2, self.loginCheck2)))
    
    def getData(self, wkt, startDate, endDate, limit, offset, producttype, total_results=False, cloud=20):
        
        producttype = "L" if producttype == "All" else producttype
        # startDate and endDate included
        try:
            url = f"""
    https://catalogue.dataspace.copernicus.eu/odata/v1/Products?&$filter=(startswith(Name,%27S2%27)%20and%20(Attributes/OData.CSC.StringAttribute/any(att:att/Name%20eq%20%27instrumentShortName%27%20and%20att/OData.CSC.StringAttribute/Value%20eq%20%27MSI%27)%20and%20Attributes/OData.CSC.DoubleAttribute/any(att:att/Name%20eq%20%27cloudCover%27%20and%20att/OData.CSC.DoubleAttribute/Value%20le%20{cloud})%20and%20(contains(Name,%27{producttype}%27)%20and%20OData.CSC.Intersects(area=geography%27SRID=4326;{wkt}%27)))%20and%20Online%20eq%20true)%20and%20ContentDate/Start%20ge%20{startDate}%20and%20ContentDate/Start%20lt%20{endDate}&$orderby=ContentDate/Start%20desc&$expand=Attributes&$count=True&$top={limit}&$expand=Assets&$skip={offset}
        """.strip()
                    
            resp = requests.get(url)
                    
            if resp.status_code == 200:
                results_json = resp.json()
                if total_results:
                    return results_json.get("@odata.count")
                else:
                    return results_json.get("value")
            else:
                if total_results:
                    return f"ERROR! --> Status Code:{resp.status_code} (total_results)"
                else:
                    return f"ERROR! --> Status Code:{resp.status_code} (get data)"
    
        except Exception as e:
            return f"ERROR! --> {str(e)}"
    
    def getProducts(self, products):
        product_list = []
        for prod in products:
            attributes = {}
            
            prod_id = prod["Id"]
            attributes["prod_id"] = prod_id
            attributes["prod_identifier"] = prod["Name"].rstrip(".SAFE")
            try:
                attributes["prod_quicklook_url"] = prod["Assets"][0]["DownloadLink"]
            except:
                attributes["prod_quicklook_url"] = ""
                
            attributes["prod_download_url"] = f"https://zipper.dataspace.copernicus.eu/odata/v1/Products({prod_id})/$value"
            
            attributes.update({i["Name"]:i["Value"] for i in prod["Attributes"]})
            
            transformer = pyproj.Transformer.from_crs(pyproj.CRS('EPSG:4326'), pyproj.CRS('EPSG:3035'), always_xy=True).transform
            attributes["area_km"] = round(transform(transformer, shape(prod["GeoFootprint"])).area/1000000)
            
            attributes["wkt"] = shape(prod["GeoFootprint"]).wkt
            
            product_list.append(attributes)
        
        df = pd.DataFrame(product_list)
        
        df["cloudCover"] = df["cloudCover"].round(2)
        df["beginningDateTime"] = pd.to_datetime(df["beginningDateTime"].str.replace("Z","").str.replace("T"," ")).dt.floor("S")
        df["endingDateTime"] = pd.to_datetime(df["endingDateTime"].str.replace("Z","").str.replace("T"," ")).dt.floor("S")
        df["processingDate"] = pd.to_datetime(df["processingDate"].str.split("+").str[0])
        
        df.columns = [i.lower() for i in df.columns]
        
        return df
    
    def getBandsFromZip(self, flist, producttype):
        extracts = []
        if producttype == "S2MSI2A":
            for img in flist:
                if "r10m" in img.lower():
                    if ("TCI" in img):
                        extracts.append(img)
                    elif ("B02" in img):
                        extracts.append(img)
                    elif ("B03" in img):
                        extracts.append(img)
                    elif ("B04" in img):
                        extracts.append(img)
                    elif ("B08" in img):
                        extracts.append(img)
                        
                elif "r20m" in img.lower():
                    if ("B05" in img):
                        extracts.append(img)
                    elif ("B06" in img):
                        extracts.append(img)
                    elif ("B07" in img):
                        extracts.append(img)
                    elif ("B8A" in img):
                        extracts.append(img)
                    elif ("B11" in img):
                        extracts.append(img)
                    elif ("B12" in img):
                        extracts.append(img)
                    elif ("SCL" in img):
                        extracts.append(img)
                
                elif "r60m" in img.lower():
                    if ("B01" in img):
                        extracts.append(img)
                    elif ("B09" in img):
                        extracts.append(img)
                    elif ("B10" in img):
                        extracts.append(img)
                
                elif "ql" in img.lower():
                    extracts.append(img)
            
            return extracts
            
        elif producttype == "S2MSI1C":
            return flist
                
    
    def executeFootprints(self):
        
        self.dlg.btn_execute.setText("Running...")
        self.dlg.processEvents() 
        
        minx = float(self.dlg.sb_extent_minx.value())
        maxx = float(self.dlg.sb_extent_maxx.value())
        miny = float(self.dlg.sb_extent_miny.value())
        maxy = float(self.dlg.sb_extent_maxy.value())        
        
        startDate = self.dlg.dt_startDate.dateTime().toPyDateTime().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        end_date_ = self.dlg.dt_endDate.dateTime().toPyDateTime()
        endDate = (end_date_ + timedelta(days=1) - timedelta(seconds=1)).strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        
        wkt = f"POLYGON(({minx} {maxy}, {maxx} {maxy}, {maxx} {miny}, {minx} {miny}, {minx} {maxy}))"
        limit = 100
        cloud = int(self.dlg.sb_cloud.value())
        producttype = self.dlg.cb_producttype.currentText()
        outFolderPath = self.dlg.le_outputFolder.text()
        
        self.createLog("Process Started", clear=True)
        
        total_results = self.getData(wkt, startDate, endDate, limit, offset=0, total_results=True, cloud=cloud, producttype=producttype)

        if isinstance(total_results, str):
            message = f"total_results couldn't retrieve - {total_results}"
            self.createLog(message)
        else:
            if total_results == 0:
                QMessageBox.information(None, "Number of Image", """No images returned after query. Change the parameters and try again.""")
            else:
                message = f"total_results : {total_results}"
                self.createLog(message)
                
                res = QMessageBox.question(None, "Number of Image", f"""{total_results} images returned after query.\nDo you want to create footprints?""")
                
                if res == QMessageBox.Yes:
                    
                    self.createLog("Creating footprints...")
                    
                    offset_list = np.arange(0, total_results, limit)
                    
                    products_all = pd.DataFrame()
                    for i,o in enumerate(offset_list, 1):
                        self.createLog(f"{i} / {len(offset_list)}")
                        products = self.getData(wkt, startDate, endDate, limit, offset=o, total_results=False, cloud=cloud, producttype=producttype)
                        
                        if isinstance(products, str):
                            message = f"{products}"
                            self.createLog(message)
                        else:
                            df = self.getProducts(products)
                            df["query_wkt"] = wkt
                            
                            products_all = pd.concat([products_all, df], axis=0)
                            time.sleep(5)
                    
                    sd = datetime.strptime(startDate, "%Y-%m-%dT%H:%M:%S.%fZ").strftime("%Y%m%d")
                    ed = datetime.strptime(endDate, "%Y-%m-%dT%H:%M:%S.%fZ").strftime("%Y%m%d")
                    
                    out_name = f""" footprints_{sd}_{ed}_{cloud}_{producttype} """.strip()
                                      
                    self.createGPKG(products_all, fr"{outFolderPath}/{out_name}.gpkg", driver_name = "GPKG")                    
                    self.createLog(fr"Exported to {outFolderPath}/{out_name}.gpkg")
                    
                    self.createLog("Footprints created.")
                    QMessageBox.information(None, "Created", """Footprints created.""")
        
        self.dlg.btn_execute.setText("Generate Footprints")
        self.dlg.processEvents()
    
        if self.dlg.cb_add_to_layer.isChecked():
            try:
                layer = QgsVectorLayer(fr"{outFolderPath}/{out_name}.gpkg", out_name, "ogr")
                QgsProject.instance().addMapLayer(layer)
            except:
                pass
                        
    def get_access_token(self):
        data = {
            "client_id": "cdse-public",
            "username": self.username,
            "password": self.password,
            "grant_type": "password",
            }
        try:
            r = requests.post("https://identity.dataspace.copernicus.eu/auth/realms/CDSE/protocol/openid-connect/token",
            data=data,
            )
            
            return r.json()["access_token"]
        
        except Exception as e:
            return f"ERROR: {str(e)}"
        
    def downloadImage(self, url, name, ql=False):
        if ql:
            outpath = fr"{self.dlg.le_outputFolder_2.text()}\{name}_ql.jpg"
        else:
            outpath = fr"{self.dlg.le_outputFolder_2.text()}\{name}.zip"
        
        self.createLog(f"{name}")
        
        session = requests.Session()
        if self.bear is None:
            self.bear = self.get_access_token()
        session.headers.update({"Authorization": f"Bearer {self.bear}"})
        
        try:
            response = session.get(url, stream=True)            
            
            if response.status_code == 200:       
                
                with open(outpath, "wb") as f:
                    for chunk in response.iter_content(chunk_size=250 * 1024):
                        f.write(chunk)
                message = "Image Downloaded!"
                
            elif response.status_code == 401:
                try:
                    self.bear = self.get_access_token()
                    session.headers.update({"Authorization": f"Bearer {self.bear}"})                    
                    response = session.get(url, stream=True)
                    
                    with open(outpath, "wb") as f:
                        for chunk in response.iter_content(chunk_size=250 * 1024):
                            f.write(chunk)
                    
                    message = "Image Downloaded!"
                
                except Exception as e:
                    message = f"ERROR!!!\n{str(e)}"
            
            else:
                message =  f"ERROR!!!\nDownload --> Image Couldn't be downloaded - Status Code:{response.status_code}"
                
        except Exception as e:
            message = f"ERROR!!!\n{str(e)}"
        
        self.createLog(message)           
            
    def executeDownloadImages(self):
        
        clip_geoms = {}
        clip_geoms2 = {}
        
        self.dlg.btn_execute_2.setText("Running...")
        self.dlg.processEvents() 
        
        file_path = self.dlg.le_inputfile.text()
        
        data = ogr.Open(file_path)
        layer = data.GetLayer()
        lyr_defn = layer.GetLayerDefn()
        field_cnt = lyr_defn.GetFieldCount()
        fields = [lyr_defn.GetFieldDefn(i).GetName() for i in range(field_cnt)]

        if not (("prod_download_url" in fields) and ("prod_identifier" in fields)):
            QMessageBox.critical(None, "ERROR", """Invalid input file. Use footprins file that created by this plugin!""")
            return
        
        self.createLog("DOWNLOAD STARTED")

        for feat in layer:
            prod_identifier = feat.GetField("prod_identifier")
            prod_url = feat.GetField("prod_download_url")
            ql_url = feat.GetField("prod_quicklook_url")
            img_name = feat.GetField("prod_identifier")
            query_geom_wkt = feat.GetField("query_wkt")
            producttype = feat.GetField("producttype")
            
            clip_geoms[prod_identifier] = query_geom_wkt
            
            if self.dlg.cb_ql.isChecked():
                try:
                    self.downloadImage(ql_url, img_name, ql=True)            
                except Exception as e:
                    self.createLog(str(e))
            else:                            
                try:
                    self.downloadImage(prod_url, img_name)
                
                    if self.dlg.cb_extract_files.isChecked():
                        self.createLog("EXTRACTING FILES...")
                                       
                        path = fr"{self.dlg.le_outputFolder_2.text()}\{img_name}.zip"
                        
                        with zipfile.ZipFile(path) as zf:
                            
                            if not os.path.isdir(f"{self.dlg.le_outputFolder_2.text()}/{img_name}"):
                                os.makedirs(f"{self.dlg.le_outputFolder_2.text()}/{img_name}")
                            
                            flist = ([i for i in zf.namelist() if (("IMG_DATA" in i) and (i.endswith("jp2"))) or ("ql" in i)])
                            
                            extracts = self.getBandsFromZip(flist, producttype)
                            
                            for z in extracts:
                                export_name = os.path.split(z)[-1]
                                
                                with open(fr"{self.dlg.le_outputFolder_2.text()}\{img_name}\{export_name}", "wb") as f:
                                    f.write(zf.read(z))
                                    
                                message = f"{export_name}\tDONE!!!"
                                self.createLog(message)
            
                        if self.dlg.cb_delete_zip_file.isChecked():
                            try:
                                os.remove(path)
                                message = "Zip File is Deleted"
                                self.createLog(message)
                            except Exception as e:
                                message = f"*** ERROR - Zip File Couldn't Be Deleted - {str(e)}"
                                self.createLog(message)
                       
                        if self.dlg.cb_ndvi.isChecked() or self.dlg.cb_ndwi.isChecked():
                            if producttype == "S2MSI2A":
                                b8_path = glob(fr"{self.dlg.le_outputFolder_2.text()}\{img_name}\*B08_10m.jp2")[0]
                                
                            elif producttype == "S2MSI1C":
                                b8_path = glob(fr"{self.dlg.le_outputFolder_2.text()}\{img_name}\*B08.jp2")[0]
                                
                            b8_raster = gdal.Open(b8_path)
                            b8_band = b8_raster.GetRasterBand(1)
                            b8_array = np.float32(np.where(b8_band.ReadAsArray() == 0, -32768, b8_band.ReadAsArray()))
                            
                            srs_b8 = b8_raster.GetSpatialRef()
                            srs_b8_wkt = srs_b8.ExportToWkt()
                            geotransform = b8_raster.GetGeoTransform()                
                        
                            if self.dlg.cb_ndvi.isChecked():
                                
                                message = "NDVI creating started."
                                self.createLog(message)
                                
                                if producttype == "S2MSI2A":
                                    b4_path = glob(fr"{self.dlg.le_outputFolder_2.text()}\{img_name}\*B04_10m.jp2")[0]
                                elif producttype == "S2MSI1C":
                                    b4_path = glob(fr"{self.dlg.le_outputFolder_2.text()}\{img_name}\*B04.jp2")[0]
                                    
                                b4_raster = gdal.Open(b4_path)
                                b4_band = b4_raster.GetRasterBand(1)
                                b4_array = np.float32(np.where(b4_band.ReadAsArray() == 0, -32768, b4_band.ReadAsArray()))
                                
                                ndvi_array_ = np.multiply(100, np.divide(np.subtract(b8_array, b4_array), np.add(b8_array, b4_array)))
                                ndvi_array = np.where((b4_array == -32768) | (b8_array == -32768), -32768, ndvi_array_)
                                
                                out_file_ndvi = b8_path.replace("B08","ndvi").replace("jp2", "tif")
                                self.array2raster(out_file_ndvi, geotransform, srs_b8_wkt, [(ndvi_array, -32768)], gdal.GDT_Int16)
                                                        
                                message = "NDVI created."
                                self.createLog(message)
                                
                            if self.dlg.cb_ndwi.isChecked():
                                
                                message = "NDWI creating started."
                                self.createLog(message)
                                
                                if producttype == "S2MSI2A":
                                    b3_path = glob(fr"{self.dlg.le_outputFolder_2.text()}\{img_name}\*B03_10m.jp2")[0]
                                    
                                elif producttype == "S2MSI1C":
                                    b3_path = glob(fr"{self.dlg.le_outputFolder_2.text()}\{img_name}\*B03.jp2")[0]
                                    
                                b3_raster = gdal.Open(b3_path)
                                b3_band = b3_raster.GetRasterBand(1)
                                b3_array = np.float32(np.where(b3_band.ReadAsArray() == 0, -32768, b3_band.ReadAsArray()))
                                
                                ndwi_array_ = np.multiply(100, np.divide(np.subtract(b3_array, b8_array), np.add(b3_array, b8_array)))
                                ndwi_array = np.where((b3_array == -32768) | (b8_array == -32768), -32768, ndwi_array_)
                                
                                out_file_ndwi = b8_path.replace("B08","ndwi").replace("jp2", "tif")
                                self.array2raster(out_file_ndwi, geotransform, srs_b8_wkt, [(ndwi_array, -32768)], gdal.GDT_Int16)
                                                        
                                message = "NDWI created."
                                self.createLog(message)
                                
                except Exception as e:
                    self.createLog(str(e))
                    
        data.FlushCache()
        data = layer = None
        del data, layer
        
        self.createLog("Images Downloaded")
        
        if self.dlg.cb_clip.isChecked():
            try:            
                message = "Clipping Images..."
                self.createLog(message)
                    
                out_folder_path_clipped = fr"{self.dlg.le_outputFolder_2.text()}\clipped_vrt"
                
                flist_for_vrt_tif = glob(fr"{self.dlg.le_outputFolder_2.text()}\*\*.tif")
                flist_for_vrt_jp2 = glob(fr"{self.dlg.le_outputFolder_2.text()}\*\*.jp2")
                flist_for_vrt = [*flist_for_vrt_tif, *flist_for_vrt_jp2]
                
                img_dict = defaultdict(list)
    
                for p in flist_for_vrt:
                    pr_id, name = p.split("\\")[-2:]
                    pr_type = pr_id.split("_")[1]    
                    name = os.path.split(p)[-1]
                    name_splitted = name.split("_", maxsplit=2)
                    
                    zone = "z" + name_splitted[0][1:3]
                    dt = name_splitted[1].split("T")[0]
                    band = name_splitted[-1].split(".")[0]
                    img_dict[f"{zone}_{dt}_{pr_type}_{band}"].append(p)
                    
                    clip_geoms2[f"{zone}_{dt}_{pr_type}_{band}"] = clip_geoms[pr_id]
                
                for name, path_list in img_dict.items():
                    zn, dt, pr_type = name.split("_")[:3]
                    
                    r = gdal.Open(path_list[0])
                    s = r.GetSpatialRef()
                    srs_wkt = s.ExportToWkt()
                    
                    minx, maxx, miny, maxy = self.getTransformedGeometry2(clip_geoms2[name], srs_wkt)
                    
                    out_folder_path = fr"{out_folder_path_clipped}\{dt}\{zn}\{pr_type}"
                    
                    if not os.path.isdir(out_folder_path):
                        os.makedirs(out_folder_path)     
                        
                    vrt_options = gdal.BuildVRTOptions(outputBounds=(minx, miny, maxx, maxy))
                    my_vrt = gdal.BuildVRT(fr"{out_folder_path}\{name}.vrt", path_list, options=vrt_options)
                    my_vrt.FlushCache()
                    my_vrt = None
                    del my_vrt
                
                self.createLog("Images Clipped as VRT.")
            
            except Exception as e:
                self.createLog(str(e))
                
            
        if self.dlg.cb_merge.isChecked():
            try:
                message = "Merging Images..."
                self.createLog(message)
                    
                out_folder_path_merged = fr"{self.dlg.le_outputFolder_2.text()}\merged_vrt"
                
                flist_for_vrt_tif = glob(fr"{self.dlg.le_outputFolder_2.text()}\*\*.tif")
                flist_for_vrt_jp2 = glob(fr"{self.dlg.le_outputFolder_2.text()}\*\*.jp2")
                flist_for_vrt = [*flist_for_vrt_tif, *flist_for_vrt_jp2]
                
                img_dict = defaultdict(list)
    
                for p in flist_for_vrt:
                    pr_id, name = p.split("\\")[-2:]
                    pr_type = pr_id.split("_")[1]    
                    name = os.path.split(p)[-1]
                    name_splitted = name.split("_", maxsplit=2)
                    
                    zone = "z" + name_splitted[0][1:3]
                    dt = name_splitted[1].split("T")[0]
                    band = name_splitted[-1].split(".")[0]
                    img_dict[f"{zone}_{dt}_{pr_type}_{band}"].append(p) 
                    
                for name, path_list in img_dict.items():
                    zn, dt, pr_type = name.split("_")[:3]                 
                    out_folder_path = fr"{out_folder_path_merged}\{dt}\{zn}\{pr_type}"
                    
                    if not os.path.isdir(out_folder_path):
                        os.makedirs(out_folder_path)            
                    
                    my_vrt = gdal.BuildVRT(fr"{out_folder_path}\{name}.vrt", path_list)
                    my_vrt.FlushCache()
                    my_vrt = None
                    del my_vrt
                
                self.createLog("Images Merged by Date as VRT.")
            
            except Exception as e:
                self.createLog(str(e))
        
        self.dlg.btn_execute_2.setText("Download Images")
        self.dlg.processEvents() 
        
        QMessageBox.information(None, "Created", """Images Downloaded.""")
    
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            # self.first_start = False
            self.dlg = DownloadSentinelDialog()
            
            self.dateCheck = True
            self.extentCheck = False
            self.folderCheck = False
            
            self.fileCheck2 = False
            self.folderCheck2 = False
            self.loginCheck2 = False
            
            self.bear = None
            
            self.pixmap_show = QPixmap(f'{self.plugin_dir}/show.png')
            self.pixmap_hide = QPixmap(f'{self.plugin_dir}/hide.png')
            self.dlg.lbl_img.setPixmap(self.pixmap_show)
            
            ed = QDate.currentDate()       
            self.dlg.dt_endDate.setDate(ed)
            
            sd = QDate.currentDate().addDays(-10)
            self.dlg.dt_startDate.setDate(sd)
                        
            layers = [v.name() for v in QgsProject.instance().mapLayers().values()]
            self.dlg.cb_layers.clear()
            self.dlg.cb_layers.addItems(layers)
            
            self.dlg.lbl_message_2.setText('<html><head/><body><p><span style=" color:#ff0000;"> Invalid extent value! </span></p></body></html>')
            self.dlg.lbl_message_3.setText('<html><head/><body><p><span style=" color:#ff0000;"> Invalid folder path! </span></p></body></html>')
            self.dlg.lbl_message_4.setText('<html><head/><body><p><span style=" color:#ff0000;"> Invalid folder path! </span></p></body></html>')
            self.dlg.lbl_message_5.setText('<html><head/><body><p><span style=" color:#ff0000;"> Invalid file path! </span></p></body></html>')
            self.dlg.lbl_message_6.setText('<html><head/><body><p><span style=" color:#ff0000;"> Login to download! </span></p></body></html>')
                        
            self.dlg.btn_canvasExtent.clicked.connect(self.getCanvasExtent)
            self.dlg.btn_layerextent.clicked.connect(self.getLayerExtent)
            self.dlg.tbtn_draw.clicked.connect(lambda x:self.getDrawnCoor(self.iface.mapCanvas()))            
         
            self.dlg.btn_execute.clicked.connect(self.executeFootprints)
            self.dlg.btn_execute_2.clicked.connect(self.executeDownloadImages)
            self.dlg.btn_browse.clicked.connect(self.selectOutputFolder)
            self.dlg.btn_browse_2.clicked.connect(self.selectOutputFolder)
            self.dlg.btn_browse_3.clicked.connect(self.selectInputFile)
            
            self.dlg.dt_startDate.dateChanged.connect(self.checkDates)
            self.dlg.dt_endDate.dateChanged.connect(self.checkDates)
            self.dlg.sb_extent_minx.valueChanged.connect(self.checkExtent)
            self.dlg.sb_extent_maxx.valueChanged.connect(self.checkExtent)
            self.dlg.sb_extent_miny.valueChanged.connect(self.checkExtent)
            self.dlg.sb_extent_maxy.valueChanged.connect(self.checkExtent)
            
            self.dlg.le_outputFolder.textChanged[str].connect(self.outFolderCheck)
            self.dlg.le_outputFolder_2.textChanged[str].connect(self.outFolderCheck)
            self.dlg.le_inputfile.textChanged[str].connect(self.inputFileCheck)
            
            self.dlg.btn_checkcreds.clicked.connect(self.checkCredentials)
            
            self.dlg.cb_extract_files.clicked.connect(self.checkExtractOptions)
            self.dlg.cb_delete_zip_file.clicked.connect(self.checkExtractOptions)
            self.dlg.cb_ndvi.clicked.connect(self.checkExtractOptions)
            self.dlg.cb_ndwi.clicked.connect(self.checkExtractOptions)
            self.dlg.cb_ql.clicked.connect(self.checkExtractOptions)
            
            self.dlg.lbl_img.mousePressEvent = self.showPassword
            self.dlg.lbl_img.mouseReleaseEvent = self.hidePassword
            
            

        self.dlg.show()
